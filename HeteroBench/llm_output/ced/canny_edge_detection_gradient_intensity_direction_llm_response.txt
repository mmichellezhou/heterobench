```cpp
void gradient_intensity_direction_optimized(const uint8_t *inImage, int height,
                                            int width, double *intensity,
                                            uint8_t *direction) {
  // Fix: memset for double array should use sizeof(double) to correctly initialize to 0.0.
  // memset(ptr, 0, size) sets all bytes to zero, which for IEEE 754 doubles represents +0.0.
  memset(intensity, 0, height * width * sizeof(double));
  memset(direction, 0, height * width);

  // Pre-calculate constant for angle conversion to avoid repeated division.
  const double ANGLE_CONVERSION_FACTOR = 360.0 / (2.0 * M_PI);

  // For a 3x3 kernel, the offset from the border is 1.
  // This constant is defined within the function scope as required.
  const int KERNEL_OFFSET = 1;

  // Loop order transformation: Iterate rows (outer loop) then columns (inner loop).
  // This improves cache locality for `inImage`, `intensity`, and `direction` arrays,
  // as image data is typically stored in row-major order.
  for (int row = KERNEL_OFFSET; row < height - KERNEL_OFFSET; row++) {
    // Pre-calculate the base index for the current row to avoid repeated multiplication
    // (row * width) in the inner loop.
    const int row_offset = row * width;

    for (int col = KERNEL_OFFSET; col < width - KERNEL_OFFSET; col++) {
      double Gx_sum = 0.0;
      double Gy_sum = 0.0;

      // Calculate the current pixel's linear index.
      const int pxIndex = row_offset + col;

      // Unroll the 3x3 convolution loop (krow from -1 to 1, kcol from -1 to 1).
      // This eliminates loop overhead and allows for better instruction scheduling.
      // Strength reduction is applied by explicitly removing multiplications by zero
      // coefficients from the Gx and Gy kernels.
      //
      // Original Gx kernel: {-1, 0, 1, -2, 0, 2, -1, 0, 1}
      // Original Gy kernel: {1, 2, 1, 0, 0, 0, -1, -2, -1}
      //
      // The `(double)inImage[...]` cast ensures that the multiplication is performed
      // using floating-point arithmetic, preventing potential intermediate integer
      // overflow and maintaining precision.

      // Contributions from the row above (krow = -1)
      Gx_sum += (double)inImage[pxIndex - width - 1] * (-1.0); // Gx[0] * P(-1,-1)
      Gy_sum += (double)inImage[pxIndex - width - 1] * (1.0);  // Gy[0] * P(-1,-1)

      // Gx[1] is 0, so no contribution to Gx_sum from P(-1,0)
      Gy_sum += (double)inImage[pxIndex - width] * (2.0);    // Gy[1] * P(-1,0)

      Gx_sum += (double)inImage[pxIndex - width + 1] * (1.0);  // Gx[2] * P(-1,+1)
      Gy_sum += (double)inImage[pxIndex - width + 1] * (1.0);  // Gy[2] * P(-1,+1)

      // Contributions from the current row (krow = 0)
      Gx_sum += (double)inImage[pxIndex - 1] * (-2.0);     // Gx[3] * P(0,-1)
      // Gy[3] is 0, so no contribution to Gy_sum from P(0,-1)

      // Gx[4] and Gy[4] are 0, so no contribution from P(0,0)

      Gx_sum += (double)inImage[pxIndex + 1] * (2.0);     // Gx[5] * P(0,+1)
      // Gy[5] is 0, so no contribution to Gy_sum from P(0,+1)

      // Contributions from the row below (krow = 1)
      Gx_sum += (double)inImage[pxIndex + width - 1] * (-1.0); // Gx[6] * P(+1,-1)
      Gy_sum += (double)inImage[pxIndex + width - 1] * (-1.0); // Gy[6] * P(+1,-1)

      // Gx[7] is 0, so no contribution to Gx_sum from P(+1,0)
      Gy_sum += (double)inImage[pxIndex + width] * (-2.0);   // Gy[7] * P(+1,0)

      Gx_sum += (double)inImage[pxIndex + width + 1] * (1.0);  // Gx[8] * P(+1,+1)
      Gy_sum += (double)inImage[pxIndex + width + 1] * (-1.0); // Gy[8] * P(+1,+1)

      // Conditional logic for intensity and direction calculation.
      // This part remains functionally identical to the original.
      if (Gx_sum == 0.0 || Gy_sum == 0.0) {
        intensity[pxIndex] = 0.0;
        direction[pxIndex] = 0;
      } else {
        intensity[pxIndex] = std::sqrt((Gx_sum * Gx_sum) + (Gy_sum * Gy_sum));
        double theta = std::atan2(Gy_sum, Gx_sum);
        theta = theta * ANGLE_CONVERSION_FACTOR;

        // Angle quantization logic.
        if ((theta <= 22.5 && theta >= -22.5) || (theta <= -157.5) || (theta >= 157.5))
          direction[pxIndex] = 1;  // horizontal -
        else if ((theta > 22.5 && theta <= 67.5) ||
                 (theta > -157.5 && theta <= -112.5))
          direction[pxIndex] = 2;  // north-east -> south-west /
        else if ((theta > 67.5 && theta <= 112.5) ||
                 (theta >= -112.5 && theta < -67.5))
          direction[pxIndex] = 3;  // vertical |
        else if ((theta >= -67.5 && theta < -22.5) ||
                 (theta > 112.5 && theta < 157.5))
          direction[pxIndex] = 4;  // north-west -> south-east \'
      }
    }
  }
}
```