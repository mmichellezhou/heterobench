```cpp
void gradient_z_calc_optimized(pixel_t frame0[MAX_HEIGHT][MAX_WIDTH],
                     pixel_t frame1[MAX_HEIGHT][MAX_WIDTH],
                     pixel_t frame2[MAX_HEIGHT][MAX_WIDTH],
                     pixel_t frame3[MAX_HEIGHT][MAX_WIDTH],
                     pixel_t frame4[MAX_HEIGHT][MAX_WIDTH],
                     pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH])
{
  // Optimization 1: Strength Reduction
  // Replace division by a constant with multiplication by its inverse.
  // This is generally faster on most CPUs as multiplication units are often
  // more plentiful and have lower latency than division units.
  const pixel_t INV_12 = 1.0f / 12.0f;

  // Optimization 2: Register Optimization / Constant Caching
  // Load the constant `GRAD_WEIGHTS` values into local `const` variables.
  // This encourages the compiler to keep these frequently used values in CPU registers,
  // reducing memory access latency and improving instruction-level parallelism.
  const pixel_t w0 = GRAD_WEIGHTS[0];
  const pixel_t w1 = GRAD_WEIGHTS[1];
  const pixel_t w2 = GRAD_WEIGHTS[2];
  const pixel_t w3 = GRAD_WEIGHTS[3];
  const pixel_t w4 = GRAD_WEIGHTS[4];

  // Optimization 3: Loop Unrolling
  // Unroll the inner loop (`c` loop) to reduce loop overhead (branching,
  // index increments, comparisons) and expose more instruction-level parallelism (ILP).
  // By processing multiple elements per iteration, the CPU's out-of-order
  // execution engine can find more independent operations to execute concurrently.
  // A common unroll factor is 4 or 8. We choose 4 for a balance between
  // reducing overhead and managing register pressure.
  const int UNROLL_FACTOR = 4;
  const int WIDTH_ALIGNED = MAX_WIDTH - (MAX_WIDTH % UNROLL_FACTOR);

  for (int r = 0; r < MAX_HEIGHT; r ++)
  {
    // Main unrolled loop: Processes elements in blocks of UNROLL_FACTOR
    for (int c = 0; c < WIDTH_ALIGNED; c += UNROLL_FACTOR)
    {
      // Optimization 4: Expression Reordering for Instruction-Level Parallelism (ILP)
      // Combine the additions and multiplications into a single expression.
      // This allows the compiler to better schedule the loads, multiplications,
      // and additions, potentially overlapping their execution on different
      // functional units of the CPU. The initial `gradient_z[r][c] = 0.0f;`
      // is removed as the first operation is now a direct assignment.

      // Calculate gradient for element c
      gradient_z[r][c] = (frame0[r][c] * w0 +
                          frame1[r][c] * w1 +
                          frame2[r][c] * w2 +
                          frame3[r][c] * w3 +
                          frame4[r][c] * w4) * INV_12;

      // Calculate gradient for element c+1
      gradient_z[r][c+1] = (frame0[r][c+1] * w0 +
                            frame1[r][c+1] * w1 +
                            frame2[r][c+1] * w2 +
                            frame3[r][c+1] * w3 +
                            frame4[r][c+1] * w4) * INV_12;

      // Calculate gradient for element c+2
      gradient_z[r][c+2] = (frame0[r][c+2] * w0 +
                            frame1[r][c+2] * w1 +
                            frame2[r][c+2] * w2 +
                            frame3[r][c+2] * w3 +
                            frame4[r][c+2] * w4) * INV_12;

      // Calculate gradient for element c+3
      gradient_z[r][c+3] = (frame0[r][c+3] * w0 +
                            frame1[r][c+3] * w1 +
                            frame2[r][c+3] * w2 +
                            frame3[r][c+3] * w3 +
                            frame4[r][c+3] * w4) * INV_12;
    }

    // Remainder loop: Handles any remaining elements that don't fit into
    // the unrolled blocks (i.e., when MAX_WIDTH is not a multiple of UNROLL_FACTOR).
    for (int c = WIDTH_ALIGNED; c < MAX_WIDTH; c ++)
    {
      gradient_z[r][c] = (frame0[r][c] * w0 +
                          frame1[r][c] * w1 +
                          frame2[r][c] * w2 +
                          frame3[r][c] * w3 +
                          frame4[r][c] * w4) * INV_12;
    }
  }
}
```