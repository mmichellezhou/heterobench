```cpp
void pad_input_optimized(double *pad_input_input, double *pad_input_output, int input_h, int input_w, int padding) {
  // Define unroll factor as a constant within the function scope
  // This helps expose instruction-level parallelism and reduces loop overhead.
  // For doubles (8 bytes), an unroll factor of 8 processes 64 bytes, aligning with common cache line sizes.
  const int UNROLL_FACTOR = 8;

  if (padding == 0) {
    // If no padding, simply copy the input to the output.
    // Optimized with pointer arithmetic and loop unrolling for better performance.
    for (int i = 0; i < input_h; i++) {
      // Use long long for offset calculation to prevent potential overflow for very large dimensions.
      double *current_output_ptr = pad_input_output + (long long)i * input_w;
      double *current_input_ptr = pad_input_input + (long long)i * input_w;

      // Unrolled loop for the main part of the row
      for (int j = 0; j < input_w / UNROLL_FACTOR; ++j) {
        current_output_ptr[j * UNROLL_FACTOR + 0] = current_input_ptr[j * UNROLL_FACTOR + 0];
        current_output_ptr[j * UNROLL_FACTOR + 1] = current_input_ptr[j * UNROLL_FACTOR + 1];
        current_output_ptr[j * UNROLL_FACTOR + 2] = current_input_ptr[j * UNROLL_FACTOR + 2];
        current_output_ptr[j * UNROLL_FACTOR + 3] = current_input_ptr[j * UNROLL_FACTOR + 3];
        current_output_ptr[j * UNROLL_FACTOR + 4] = current_input_ptr[j * UNROLL_FACTOR + 4];
        current_output_ptr[j * UNROLL_FACTOR + 5] = current_input_ptr[j * UNROLL_FACTOR + 5];
        current_output_ptr[j * UNROLL_FACTOR + 6] = current_input_ptr[j * UNROLL_FACTOR + 6];
        current_output_ptr[j * UNROLL_FACTOR + 7] = current_input_ptr[j * UNROLL_FACTOR + 7];
      }
      // Handle any remaining elements that don't fit into the unrolled loop
      for (int j = (input_w / UNROLL_FACTOR) * UNROLL_FACTOR; j < input_w; ++j) {
        current_output_ptr[j] = current_input_ptr[j];
      }
    }
    return;
  }

  // Calculate the width of the padded output array once (strength reduction)
  const int padded_w = input_w + 2 * padding;

  // Use pointers to traverse rows, avoiding repeated multiplication for row offsets.
  double *current_output_row_ptr = pad_input_output;
  double *current_input_row_ptr = pad_input_input;

  // 1. Zero the top 'padding' rows
  // This loop initializes the top padding region of the output array to 0.0.
  for (int i = 0; i < padding; ++i) {
    // Unrolled loop for zeroing elements in the current row
    for (int j = 0; j < padded_w / UNROLL_FACTOR; ++j) {
      current_output_row_ptr[j * UNROLL_FACTOR + 0] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 1] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 2] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 3] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 4] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 5] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 6] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 7] = 0.0;
    }
    // Handle any remaining elements
    for (int j = (padded_w / UNROLL_FACTOR) * UNROLL_FACTOR; j < padded_w; ++j) {
      current_output_row_ptr[j] = 0.0;
    }
    // Advance the output pointer to the next row
    current_output_row_ptr += padded_w;
  }

  // 2. Process the 'input_h' middle rows (where the original input data goes)
  // This section combines zeroing of left/right padding and copying of input data
  // into a single loop structure, reducing redundant memory writes (dead store elimination).
  for (int i = 0; i < input_h; ++i) {
    // Zero the left padding for the current row
    for (int j = 0; j < padding / UNROLL_FACTOR; ++j) {
      current_output_row_ptr[j * UNROLL_FACTOR + 0] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 1] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 2] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 3] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 4] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 5] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 6] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 7] = 0.0;
    }
    // Handle remainder for left padding
    for (int j = (padding / UNROLL_FACTOR) * UNROLL_FACTOR; j < padding; ++j) {
      current_output_row_ptr[j] = 0.0;
    }

    // Copy the input data for the current row into the padded output
    // The destination starts after the left padding.
    double *output_data_start_ptr = current_output_row_ptr + padding;
    for (int j = 0; j < input_w / UNROLL_FACTOR; ++j) {
      output_data_start_ptr[j * UNROLL_FACTOR + 0] = current_input_row_ptr[j * UNROLL_FACTOR + 0];
      output_data_start_ptr[j * UNROLL_FACTOR + 1] = current_input_row_ptr[j * UNROLL_FACTOR + 1];
      output_data_start_ptr[j * UNROLL_FACTOR + 2] = current_input_row_ptr[j * UNROLL_FACTOR + 2];
      output_data_start_ptr[j * UNROLL_FACTOR + 3] = current_input_row_ptr[j * UNROLL_FACTOR + 3];
      output_data_start_ptr[j * UNROLL_FACTOR + 4] = current_input_row_ptr[j * UNROLL_FACTOR + 4];
      output_data_start_ptr[j * UNROLL_FACTOR + 5] = current_input_row_ptr[j * UNROLL_FACTOR + 5];
      output_data_start_ptr[j * UNROLL_FACTOR + 6] = current_input_row_ptr[j * UNROLL_FACTOR + 6];
      output_data_start_ptr[j * UNROLL_FACTOR + 7] = current_input_row_ptr[j * UNROLL_FACTOR + 7];
    }
    // Handle remainder for input data copy
    for (int j = (input_w / UNROLL_FACTOR) * UNROLL_FACTOR; j < input_w; ++j) {
      output_data_start_ptr[j] = current_input_row_ptr[j];
    }

    // Zero the right padding for the current row
    // The destination starts after the input data.
    double *output_right_padding_start_ptr = current_output_row_ptr + padding + input_w;
    for (int j = 0; j < padding / UNROLL_FACTOR; ++j) {
      output_right_padding_start_ptr[j * UNROLL_FACTOR + 0] = 0.0;
      output_right_padding_start_ptr[j * UNROLL_FACTOR + 1] = 0.0;
      output_right_padding_start_ptr[j * UNROLL_FACTOR + 2] = 0.0;
      output_right_padding_start_ptr[j * UNROLL_FACTOR + 3] = 0.0;
      output_right_padding_start_ptr[j * UNROLL_FACTOR + 4] = 0.0;
      output_right_padding_start_ptr[j * UNROLL_FACTOR + 5] = 0.0;
      output_right_padding_start_ptr[j * UNROLL_FACTOR + 6] = 0.0;
      output_right_padding_start_ptr[j * UNROLL_FACTOR + 7] = 0.0;
    }
    // Handle remainder for right padding
    for (int j = (padding / UNROLL_FACTOR) * UNROLL_FACTOR; j < padding; ++j) {
      output_right_padding_start_ptr[j] = 0.0;
    }

    // Advance pointers to the next rows
    current_output_row_ptr += padded_w;
    current_input_row_ptr += input_w;
  }

  // 3. Zero the bottom 'padding' rows
  // This loop initializes the bottom padding region of the output array to 0.0.
  // current_output_row_ptr is already positioned at the start of the bottom padding rows.
  for (int i = 0; i < padding; ++i) {
    // Unrolled loop for zeroing elements in the current row
    for (int j = 0; j < padded_w / UNROLL_FACTOR; ++j) {
      current_output_row_ptr[j * UNROLL_FACTOR + 0] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 1] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 2] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 3] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 4] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 5] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 6] = 0.0;
      current_output_row_ptr[j * UNROLL_FACTOR + 7] = 0.0;
    }
    // Handle any remaining elements
    for (int j = (padded_w / UNROLL_FACTOR) * UNROLL_FACTOR; j < padded_w; ++j) {
      current_output_row_ptr[j] = 0.0;
    }
    // Advance the output pointer to the next row
    current_output_row_ptr += padded_w;
  }
}
```