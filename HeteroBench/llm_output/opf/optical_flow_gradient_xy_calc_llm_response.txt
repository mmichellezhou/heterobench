```cpp
void gradient_xy_calc_optimized(pixel_t frame[MAX_HEIGHT][MAX_WIDTH],
    pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],
    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH])
{
  // The original function's logic involves two distinct regions for writing to gradient_x/y:
  // 1. A central region where actual gradient computation occurs.
  // 2. A border region where gradient values are set to 0.
  // Other regions of the output arrays are left untouched.
  // To optimize, we separate these regions into distinct loops to eliminate conditional branches
  // from the hot path and improve cache locality for the zeroing operations.

  // 1. Zero out the border regions of gradient_x and gradient_y.
  // These correspond to the `else if (r >= 2 && c >= 2)` block in the original code,
  // covering the output indices [0..MAX_HEIGHT-1][0..MAX_WIDTH-1] that are not
  // part of the main computation region.

  // Zero top 2 rows (output r_out = 0, 1)
  for (int r_out = 0; r_out < 2; ++r_out) {
      for (int c_out = 0; c_out < MAX_WIDTH; ++c_out) {
          gradient_x[r_out][c_out] = 0;
          gradient_y[r_out][c_out] = 0;
      }
  }

  // Zero bottom 2 rows (output r_out = MAX_HEIGHT-2, MAX_HEIGHT-1)
  // This loop only executes if MAX_HEIGHT is large enough for these rows to exist
  // and be distinct from the top rows.
  if (MAX_HEIGHT > 2) {
    for (int r_out = MAX_HEIGHT - 2; r_out < MAX_HEIGHT; ++r_out) {
        for (int c_out = 0; c_out < MAX_WIDTH; ++c_out) {
            gradient_x[r_out][c_out] = 0;
            gradient_y[r_out][c_out] = 0;
        }
    }
  }

  // Zero left 2 columns (output c_out = 0, 1), excluding the top/bottom 2 rows already handled.
  // This loop only executes if MAX_WIDTH is large enough and there are middle rows.
  if (MAX_WIDTH > 2) {
    for (int r_out = 2; r_out < MAX_HEIGHT - 2; ++r_out) {
        for (int c_out = 0; c_out < 2; ++c_out) {
            gradient_x[r_out][c_out] = 0;
            gradient_y[r_out][c_out] = 0;
        }
    }

    // Zero right 2 columns (output c_out = MAX_WIDTH-2, MAX_WIDTH-1), excluding top/bottom 2 rows.
    // This loop only executes if MAX_WIDTH is large enough and there are middle rows.
    for (int r_out = 2; r_out < MAX_HEIGHT - 2; ++r_out) {
        for (int c_out = MAX_WIDTH - 2; c_out < MAX_WIDTH; ++c_out) {
            gradient_x[r_out][c_out] = 0;
            gradient_y[r_out][c_out] = 0;
        }
    }
  }

  // 2. Main Computation Loop.
  // This region corresponds to the original `if (r >= 4 && r < MAX_HEIGHT && c >= 4 && c < MAX_WIDTH)` block.
  // The output indices (r-2, c-2) range from (2,2) to (MAX_HEIGHT-3, MAX_WIDTH-3).
  // This loop only executes if MAX_HEIGHT >= 4 and MAX_WIDTH >= 4, ensuring the central region exists.
  for (int r = 4; r < MAX_HEIGHT; r++)
  {
    for (int c = 4; c < MAX_WIDTH; c++)
    {
      pixel_t x_grad = 0;
      pixel_t y_grad = 0;

      // Loop Unrolling: The innermost 'i' loop has a fixed iteration count of 5.
      // Unrolling it completely eliminates loop overhead and exposes more instruction-level
      // parallelism for the CPU's out-of-order execution engine.
      // This also allows the compiler to better optimize register usage for intermediate calculations.

      // i = 0: GRAD_WEIGHTS[4-0] = GRAD_WEIGHTS[4]
      x_grad += frame[r-2][c-0] * GRAD_WEIGHTS[4];
      y_grad += frame[r-0][c-2] * GRAD_WEIGHTS[4];

      // i = 1: GRAD_WEIGHTS[4-1] = GRAD_WEIGHTS[3]
      x_grad += frame[r-2][c-1] * GRAD_WEIGHTS[3];
      y_grad += frame[r-1][c-2] * GRAD_WEIGHTS[3];

      // i = 2: GRAD_WEIGHTS[4-2] = GRAD_WEIGHTS[2]
      // Note: frame[r-2][c-2] is a common subexpression for both x_grad and y_grad here.
      // The compiler should optimize this to a single memory load.
      x_grad += frame[r-2][c-2] * GRAD_WEIGHTS[2];
      y_grad += frame[r-2][c-2] * GRAD_WEIGHTS[2];

      // i = 3: GRAD_WEIGHTS[4-3] = GRAD_WEIGHTS[1]
      x_grad += frame[r-2][c-3] * GRAD_WEIGHTS[1];
      y_grad += frame[r-3][c-2] * GRAD_WEIGHTS[1];

      // i = 4: GRAD_WEIGHTS[4-4] = GRAD_WEIGHTS[0]
      x_grad += frame[r-2][c-4] * GRAD_WEIGHTS[0];
      y_grad += frame[r-4][c-2] * GRAD_WEIGHTS[0];

      // Strength Reduction: Division by a constant (12) is typically optimized by compilers
      // into a sequence of multiplications and shifts for integer types, which is faster.
      // For floating-point types, it would be optimized to multiplication by reciprocal.
      gradient_x[r-2][c-2] = x_grad / 12;
      gradient_y[r-2][c-2] = y_grad / 12;
    }
  }
}
```