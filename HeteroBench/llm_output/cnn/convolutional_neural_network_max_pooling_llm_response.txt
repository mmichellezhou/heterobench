```cpp
void max_pooling_optimized(double *max_pooling_input, int pool_size, int pool_stride, int input_h, int input_w, double *max_pooling_output) {
  int output_h = (input_h - pool_size) / pool_stride + 1;
  int output_w = (input_w - pool_size) / pool_stride + 1;

  for (int i = 0; i < output_h; i++) {
    // Strength Reduction: Pre-calculate the starting row offset for the current pooling window.
    // This is (i * pool_stride) * input_w, which is invariant for the inner 'j' loop.
    // Using pointer arithmetic directly from max_pooling_input for efficiency.
    const double* input_row_base_ptr = max_pooling_input + (long long)i * pool_stride * input_w;

    for (int j = 0; j < output_w; j++) {
      // Strength Reduction: Pre-calculate the starting column offset for the current pooling window.
      // This is j * pool_stride.
      const int current_window_col_start_offset = j * pool_stride;

      // Pointer Optimization: Calculate the pointer to the very first element of the current pooling region.
      const double* region_start_ptr = input_row_base_ptr + current_window_col_start_offset;

      // Register Optimization & Instruction-Level Parallelism:
      // Initialize multiple accumulators for scalar unrolling.
      // All accumulators are initialized with the first element of the region (region_start_ptr[0]).
      // This ensures functional equivalence with np.max (correctly handling negative numbers)
      // and simplifies boundary conditions for small pool_size values.
      double max_val0 = region_start_ptr[0];
      double max_val1 = max_val0;
      double max_val2 = max_val0;
      double max_val3 = max_val0;

      // Loop Transformation: Iterate over the rows within the pool_size x pool_size region.
      for (int k = 0; k < pool_size; k++) {
        // Strength Reduction & Pointer Optimization: Calculate the pointer to the start of the current row within the region.
        // This avoids repeated multiplication (k * input_w) inside the innermost loop.
        const double* current_row_ptr = region_start_ptr + (long long)k * input_w;

        int l = 0;
        // Loop Unrolling: Unroll the innermost loop by 4 to expose more instruction-level parallelism.
        // Each accumulator processes a different element in parallel, reducing loop overhead and
        // allowing the CPU's out-of-order execution engine to find independent operations.
        for (; l + 3 < pool_size; l += 4) {
          max_val0 = std::max(max_val0, current_row_ptr[l]);
          max_val1 = std::max(max_val1, current_row_ptr[l+1]);
          max_val2 = std::max(max_val2, current_row_ptr[l+2]);
          max_val3 = std::max(max_val3, current_row_ptr[l+3]);
        }
        // Cleanup loop for remaining elements if pool_size is not a multiple of 4.
        for (; l < pool_size; l++) {
          max_val0 = std::max(max_val0, current_row_ptr[l]);
        }
      }

      // Combine the results from the multiple accumulators to get the final maximum value for the region.
      double final_max_val = std::max(std::max(max_val0, max_val1), std::max(max_val2, max_val3));
      max_pooling_output[i * output_w + j] = final_max_val;
    }
  }
}
```