{
  "function_name": "kernel_adi",
  "original_file_path": "benchmarks/alternating_direction_implicit/homobackend_cpu/Cpp/cpu_impl/kernel_adi.cpp",
  "optimized_file_path": "benchmarks/alternating_direction_implicit/homobackend_cpu/Cpp/cpu_impl_optimized/kernel_adi_optimized.cpp",
  "status": {
    "function_generation_success": true,
    "compilation_success": false,
    "execution_success": false,
    "verification_success": false
  },
  "statistics": {
    "num_code_blocks_generated": 1,
    "optimized_code_length": 9115,
    "prompt_length": 5718,
    "llm_response_length": 9126
  },
  "details": {
    "entire_llm_response": {
      "model": "gemini-2.5-flash-preview-05-20",
      "provider": "google",
      "temperature": 0.0,
      "max_tokens": 65536,
      "response": {
        "id": "HwFVaLmsMJCg1MkPtdOjiAM",
        "choices": [
          {
            "index": 0,
            "message": {
              "role": "assistant",
              "content": "```cpp\nvoid kernel_adi_optimized(int tsteps,int n,double X[N + 0][N + 0],double A[N + 0][N + 0],double B[N + 0][N + 0])\n{\n  // Constants for unrolling and tiling.\n  // These values are chosen to balance register pressure, instruction-level parallelism (ILP),\n  // and cache locality for typical CPU architectures (e.g., Intel Xeon Gold 6248R).\n  // For double-precision floating-point numbers (8 bytes), a cache line (64 bytes) holds 8 doubles.\n  // U_H: Unroll factor for horizontal sweeps (inner c8 loop).\n  // BLOCK_C2: Tiling factor for the c2 loop in vertical sweeps to improve cache locality.\n  //           A block size of 16 means 16 doubles (128 bytes) are processed contiguously\n  //           in the innermost loop, which should fit well within L1 cache and exploit spatial locality.\n  // U_V: Unroll factor for the innermost c2 loop within the tiled vertical sweeps.\n  const int U_H = 4;\n  const int BLOCK_C2 = 16;\n  const int U_V = 4;\n\n  // Main time-stepping loop\n  for (int c0 = 0; c0 <= TSTEPS; ++c0) {\n    // Phase 1: Horizontal sweeps (row-major access, inherently good cache locality)\n    for (int c2 = 0; c2 < N; ++c2) { // Iterate over rows\n      // Fused forward sweeps for B and X\n      // Original:\n      // for (c8 = 1; c8 <= N - 1; c8++) { B[c2][c8] = B[c2][c8] - A[c2][c8] * A[c2][c8] / B[c2][c8 - 1]; }\n      // for (c8 = 1; c8 <= N - 1; c8++) { X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * A[c2][c8] / B[c2][c8 - 1]; }\n      // Optimizations: Loop fusion, strength reduction (division to multiplication by reciprocal), loop unrolling.\n      int c8_limit_unrolled = N - 1 - ((N - 1 - 1 + 1) % U_H); // Calculate upper bound for unrolled loop\n      for (int c8 = 1; c8 <= c8_limit_unrolled; c8 += U_H) {\n        // Iteration c8\n        double inv_B_prev_0 = 1.0 / B[c2][c8 - 1];\n        double common_factor_0 = A[c2][c8] * inv_B_prev_0;\n        B[c2][c8] = B[c2][c8] - A[c2][c8] * common_factor_0;\n        X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * common_factor_0;\n\n        // Iteration c8 + 1\n        double inv_B_prev_1 = 1.0 / B[c2][c8]; // B[c2][c8] is the newly computed value\n        double common_factor_1 = A[c2][c8 + 1] * inv_B_prev_1;\n        B[c2][c8 + 1] = B[c2][c8 + 1] - A[c2][c8 + 1] * common_factor_1;\n        X[c2][c8 + 1] = X[c2][c8 + 1] - X[c2][c8] * common_factor_1;\n\n        // Iteration c8 + 2\n        double inv_B_prev_2 = 1.0 / B[c2][c8 + 1];\n        double common_factor_2 = A[c2][c8 + 2] * inv_B_prev_2;\n        B[c2][c8 + 2] = B[c2][c8 + 2] - A[c2][c8 + 2] * common_factor_2;\n        X[c2][c8 + 2] = X[c2][c8 + 2] - X[c2][c8 + 1] * common_factor_2;\n\n        // Iteration c8 + 3\n        double inv_B_prev_3 = 1.0 / B[c2][c8 + 2];\n        double common_factor_3 = A[c2][c8 + 3] * inv_B_prev_3;\n        B[c2][c8 + 3] = B[c2][c8 + 3] - A[c2][c8 + 3] * common_factor_3;\n        X[c2][c8 + 3] = X[c2][c8 + 3] - X[c2][c8 + 2] * common_factor_3;\n      }\n      // Remainder loop for forward sweeps\n      for (int c8 = c8_limit_unrolled + 1; c8 < N; ++c8) {\n        double inv_B_prev = 1.0 / B[c2][c8 - 1];\n        double common_factor = A[c2][c8] * inv_B_prev;\n        B[c2][c8] = B[c2][c8] - A[c2][c8] * common_factor;\n        X[c2][c8] = X[c2][c8] - X[c2][c8 - 1] * common_factor;\n      }\n\n      // Backward sweep for X\n      // Original:\n      // for (c8 = 0; c8 <= N - 3; c8++) { X[c2][N - c8 - 2] = (X[c2][N - 2 - c8] - X[c2][N - 2 - c8 - 1] * A[c2][N - c8 - 3]) / B[c2][N - 3 - c8]; }\n      // Transformation: Let k = N - c8 - 2. Loop becomes for (k = N-2; k >= 1; k--)\n      // X[c2][k] = (X[c2][k] - X[c2][k - 1] * A[c2][k - 1]) / B[c2][k - 1];\n      // Optimizations: Strength reduction (division to multiplication by reciprocal), loop unrolling.\n      int k_start = N - 2;\n      int k_end_unrolled = 1 + U_H - 1; // Smallest k for unrolled loop\n      for (int k = k_start; k >= k_end_unrolled; k -= U_H) {\n        // Iteration k\n        double inv_B_k_minus_1_0 = 1.0 / B[c2][k - 1];\n        X[c2][k] = (X[c2][k] - X[c2][k - 1] * A[c2][k - 1]) * inv_B_k_minus_1_0;\n\n        // Iteration k - 1\n        double inv_B_k_minus_1_1 = 1.0 / B[c2][k - 2];\n        X[c2][k - 1] = (X[c2][k - 1] - X[c2][k - 2] * A[c2][k - 2]) * inv_B_k_minus_1_1;\n\n        // Iteration k - 2\n        double inv_B_k_minus_1_2 = 1.0 / B[c2][k - 3];\n        X[c2][k - 2] = (X[c2][k - 2] - X[c2][k - 3] * A[c2][k - 3]) * inv_B_k_minus_1_2;\n\n        // Iteration k - 3\n        double inv_B_k_minus_1_3 = 1.0 / B[c2][k - 4];\n        X[c2][k - 3] = (X[c2][k - 3] - X[c2][k - 4] * A[c2][k - 4]) * inv_B_k_minus_1_3;\n      }\n      // Remainder loop for backward sweep\n      for (int k = k_end_unrolled - 1; k >= 1; --k) {\n        double inv_B_k_minus_1 = 1.0 / B[c2][k - 1];\n        X[c2][k] = (X[c2][k] - X[c2][k - 1] * A[c2][k - 1]) * inv_B_k_minus_1;\n      }\n    }\n    // Final single element division for horizontal sweeps\n    // Original: for (c2 = 0; c2 <= N - 1; c2++) { X[c2][N - 1] = X[c2][N - 1] / B[c2][N - 1]; }\n    for (int c2 = 0; c2 < N; ++c2) {\n      X[c2][N - 1] = X[c2][N - 1] / B[c2][N - 1];\n    }\n\n    // Phase 2: Vertical sweeps (column-major access, poor cache locality without tiling)\n    // Optimizations: Loop reordering (tiling c2), loop fusion, strength reduction, unrolling c2.\n    for (int c2_block = 0; c2_block < N; c2_block += BLOCK_C2) { // Tile c2 (columns)\n      // Fused forward sweeps for B and X\n      // Original:\n      // for (c8 = 1; c8 <= N - 1; c8++) { B[c8][c2] = B[c8][c2] - A[c8][c2] * A[c8][c2] / B[c8 - 1][c2]; }\n      // for (c8 = 1; c8 <= N - 1; c8++) { X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * A[c8][c2] / B[c8 - 1][c2]; }\n      for (int c8 = 1; c8 < N; ++c8) { // Iterate over rows (middle loop for dependencies)\n        for (int c2 = c2_block; c2 < c2_block + BLOCK_C2 && c2 < N; c2 += U_V) { // Iterate over columns within block (innermost for locality)\n          // Iteration c2\n          double inv_B_prev_0 = 1.0 / B[c8 - 1][c2];\n          double common_factor_0 = A[c8][c2] * inv_B_prev_0;\n          B[c8][c2] = B[c8][c2] - A[c8][c2] * common_factor_0;\n          X[c8][c2] = X[c8][c2] - X[c8 - 1][c2] * common_factor_0;\n\n          // Iteration c2 + 1\n          if (c2 + 1 < c2_block + BLOCK_C2 && c2 + 1 < N) {\n            double inv_B_prev_1 = 1.0 / B[c8 - 1][c2 + 1];\n            double common_factor_1 = A[c8][c2 + 1] * inv_B_prev_1;\n            B[c8][c2 + 1] = B[c8][c2 + 1] - A[c8][c2 + 1] * common_factor_1;\n            X[c8][c2 + 1] = X[c8][c2 + 1] - X[c8 - 1][c2 + 1] * common_factor_1;\n          }\n\n          // Iteration c2 + 2\n          if (c2 + 2 < c2_block + BLOCK_C2 && c2 + 2 < N) {\n            double inv_B_prev_2 = 1.0 / B[c8 - 1][c2 + 2];\n            double common_factor_2 = A[c8][c2 + 2] * inv_B_prev_2;\n            B[c8][c2 + 2] = B[c8][c2 + 2] - A[c8][c2 + 2] * common_factor_2;\n            X[c8][c2 + 2] = X[c8][c2 + 2] - X[c8 - 1][c2 + 2] * common_factor_2;\n          }\n\n          // Iteration c2 + 3\n          if (c2 + 3 < c2_block + BLOCK_C2 && c2 + 3 < N) {\n            double inv_B_prev_3 = 1.0 / B[c8 - 1][c2 + 3];\n            double common_factor_3 = A[c8][c2 + 3] * inv_B_prev_3;\n            B[c8][c2 + 3] = B[c8][c2 + 3] - A[c8][c2 + 3] * common_factor_3;\n            X[c8][c2 + 3] = X[c8][c2 + 3] - X[c8 - 1][c2 + 3] * common_factor_3;\n          }\n        }\n      }\n\n      // Backward sweep for X\n      // Original:\n      // for (c8 = 0; c8 <= N - 3; c8++) { X[N - 2 - c8][c2] = (X[N - 2 - c8][c2] - X[N - c8 - 3][c2] * A[N - 3 - c8][c2]) / B[N - 2 - c8][c2]; }\n      // Transformation: Let k = N - 2 - c8. Loop becomes for (k = N-2; k >= 1; k--)\n      // X[k][c2] = (X[k][c2] - X[k - 1][c2] * A[k - 1][c2]) / B[k][c2];\n      // Optimizations: Strength reduction (division to multiplication by reciprocal), unrolling c2.\n      for (int k = N - 2; k >= 1; --k) { // Iterate over rows (outer loop for dependencies)\n        for (int c2 = c2_block; c2 < c2_block + BLOCK_C2 && c2 < N; c2 += U_V) { // Iterate over columns within block (innermost for locality)\n          // Iteration c2\n          double inv_B_k_0 = 1.0 / B[k][c2];\n          X[k][c2] = (X[k][c2] - X[k - 1][c2] * A[k - 1][c2]) * inv_B_k_0;\n\n          // Iteration c2 + 1\n          if (c2 + 1 < c2_block + BLOCK_C2 && c2 + 1 < N) {\n            double inv_B_k_1 = 1.0 / B[k][c2 + 1];\n            X[k][c2 + 1] = (X[k][c2 + 1] - X[k - 1][c2 + 1] * A[k - 1][c2 + 1]) * inv_B_k_1;\n          }\n\n          // Iteration c2 + 2\n          if (c2 + 2 < c2_block + BLOCK_C2 && c2 + 2 < N) {\n            double inv_B_k_2 = 1.0 / B[k][c2 + 2];\n            X[k][c2 + 2] = (X[k][c2 + 2] - X[k - 1][c2 + 2] * A[k - 1][c2 + 2]) * inv_B_k_2;\n          }\n\n          // Iteration c2 + 3\n          if (c2 + 3 < c2_block + BLOCK_C2 && c2 + 3 < N) {\n            double inv_B_k_3 = 1.0 / B[k][c2 + 3];\n            X[k][c2 + 3] = (X[k][c2 + 3] - X[k - 1][c2 + 3] * A[k - 1][c2 + 3]) * inv_B_k_3;\n          }\n        }\n      }\n    }\n    // Final single element division for vertical sweeps\n    // Original: for (c2 = 0; c2 <= N - 1; c2++) { X[N - 1][c2] = X[N - 1][c2] / B[N - 1][c2]; }\n    for (int c2 = 0; c2 < N; ++c2) {\n      X[N - 1][c2] = X[N - 1][c2] / B[N - 1][c2];\n    }\n  }\n}\n```",
              "function_call": null,
              "tool_calls": null
            },
            "finish_reason": "stop"
          }
        ],
        "created": 1750401311,
        "model": "gemini-2.5-flash-preview-05-20",
        "usage": {
          "prompt_tokens": 2299,
          "completion_tokens": 4235,
          "total_tokens": 21804
        }
      }
    }
  }
}