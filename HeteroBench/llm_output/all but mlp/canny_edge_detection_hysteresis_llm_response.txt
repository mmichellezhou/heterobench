```cpp
void hysteresis_optimized(uint8_t *inImage, int height, int width,
                          uint8_t *outImage) {
  // Copy input image to output image. This is a large block memory copy,
  // which is typically highly optimized by the system's memcpy.
  // The size argument for memcpy should be size_t to handle potentially large images.
  memcpy(outImage, inImage, (size_t)width * height * sizeof(uint8_t));

  // Loop transformation: Iterate rows in the outer loop and columns in the inner loop.
  // This ensures contiguous memory accesses within the innermost loop (column iteration),
  // which significantly improves cache locality and performance on modern CPUs.
  // The loop bounds respect the OFFSET constant for border handling,
  // ensuring that neighbor accesses are always within image bounds.
  for (int row = OFFSET; row < height - OFFSET; ++row) {
    // Pre-calculate base pointers for the current, previous, and next rows.
    // Using long long for intermediate multiplication to prevent potential overflow
    // if width * row exceeds INT_MAX, before being used in pointer arithmetic.
    uint8_t *p_prev_row = outImage + (long long)(row - 1) * width;
    uint8_t *p_curr_row = outImage + (long long)row * width;
    uint8_t *p_next_row = outImage + (long long)(row + 1) * width;

    // Loop unrolling for the inner column loop.
    // Unrolling by 4 to expose more instruction-level parallelism (ILP) and
    // allow for better register reuse of neighbor values across iterations.
    // This also reduces loop overhead (branching, loop counter increments).
    int col = OFFSET;
    for (; col < width - OFFSET - 3; col += 4) {
      // Prefetch data for future iterations to reduce cache misses.
      // __builtin_prefetch is a GCC/Clang intrinsic that hints to the CPU's prefetcher.
      // It requests to prefetch the next block of 4 columns for the previous, current, and next rows.
      // '0' indicates a read operation, '1' indicates low temporal locality (data will be used soon but not repeatedly).
      __builtin_prefetch(p_prev_row + col + 4, 0, 1);
      __builtin_prefetch(p_curr_row + col + 4, 0, 1);
      __builtin_prefetch(p_next_row + col + 4, 0, 1);

      // Process pixel at col
      uint8_t val_curr0 = p_curr_row[col];
      if (val_curr0 == 100) {
        // Check 8 neighbors for the value 255.
        // The compiler will optimize the boolean OR operations, potentially short-circuiting.
        bool neighbor_255_0 = (p_prev_row[col - 1] == 255 || p_prev_row[col] == 255 || p_prev_row[col + 1] == 255 ||
                               p_curr_row[col - 1] == 255 || p_curr_row[col + 1] == 255 ||
                               p_next_row[col - 1] == 255 || p_next_row[col] == 255 || p_next_row[col + 1] == 255);
        p_curr_row[col] = neighbor_255_0 ? 255 : 0;
      }

      // Process pixel at col + 1
      uint8_t val_curr1 = p_curr_row[col + 1];
      if (val_curr1 == 100) {
        bool neighbor_255_1 = (p_prev_row[col] == 255 || p_prev_row[col + 1] == 255 || p_prev_row[col + 2] == 255 ||
                               p_curr_row[col] == 255 || p_curr_row[col + 2] == 255 ||
                               p_next_row[col] == 255 || p_next_row[col + 1] == 255 || p_next_row[col + 2] == 255);
        p_curr_row[col + 1] = neighbor_255_1 ? 255 : 0;
      }

      // Process pixel at col + 2
      uint8_t val_curr2 = p_curr_row[col + 2];
      if (val_curr2 == 100) {
        bool neighbor_255_2 = (p_prev_row[col + 1] == 255 || p_prev_row[col + 2] == 255 || p_prev_row[col + 3] == 255 ||
                               p_curr_row[col + 1] == 255 || p_curr_row[col + 3] == 255 ||
                               p_next_row[col + 1] == 255 || p_next_row[col + 2] == 255 || p_next_row[col + 3] == 255);
        p_curr_row[col + 2] = neighbor_255_2 ? 255 : 0;
      }

      // Process pixel at col + 3
      uint8_t val_curr3 = p_curr_row[col + 3];
      if (val_curr3 == 100) {
        bool neighbor_255_3 = (p_prev_row[col + 2] == 255 || p_prev_row[col + 3] == 255 || p_prev_row[col + 4] == 255 ||
                               p_curr_row[col + 2] == 255 || p_curr_row[col + 4] == 255 ||
                               p_next_row[col + 2] == 255 || p_next_row[col + 3] == 255 || p_next_row[col + 4] == 255);
        p_curr_row[col + 3] = neighbor_255_3 ? 255 : 0;
      }
    }

    // Remainder loop for columns that couldn't be processed in blocks of 4.
    // This ensures correct processing for image widths not perfectly divisible by 4.
    for (; col < width - OFFSET; ++col) {
      uint8_t val_curr = p_curr_row[col];
      if (val_curr == 100) {
        bool neighbor_255 = (p_prev_row[col - 1] == 255 || p_prev_row[col] == 255 || p_prev_row[col + 1] == 255 ||
                             p_curr_row[col - 1] == 255 || p_curr_row[col + 1] == 255 ||
                             p_next_row[col - 1] == 255 || p_next_row[col] == 255 || p_next_row[col + 1] == 255);
        p_curr_row[col] = neighbor_255 ? 255 : 0;
      }
    }
  }
}
```