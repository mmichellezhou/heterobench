```cpp
void softmax_optimized(double *softmax_input, double *exp_results, double *softmax_output, int size)
{
  // Initialize main sum accumulator
  double sum_total_0 = 0.0;

  // Define unroll factor for loop transformations.
  // This constant is defined within the function scope as required.
  const int UNROLL_FACTOR = 4;

  // Initialize multiple accumulators for the sum to improve Instruction-Level Parallelism (ILP).
  // This helps reduce the dependency chain length for the sum operation.
  double sum_acc0 = 0.0;
  double sum_acc1 = 0.0;
  double sum_acc2 = 0.0;
  double sum_acc3 = 0.0;

  int i = 0;

  // First loop: Compute exp(input) and accumulate sum_total_0.
  // Loop unrolling is applied to expose more independent operations for ILP.
  for (; i + UNROLL_FACTOR <= size; i += UNROLL_FACTOR) {
    // Load input values
    double val0 = softmax_input[i];
    double val1 = softmax_input[i+1];
    double val2 = softmax_input[i+2];
    double val3 = softmax_input[i+3];

    // Compute exponential for each value. These operations can potentially
    // execute in parallel on modern CPUs.
    double exp_val0 = exp(val0);
    double exp_val1 = exp(val1);
    double exp_val2 = exp(val2);
    double exp_val3 = exp(val3);

    // Store the exponential results in the intermediate array.
    exp_results[i] = exp_val0;
    exp_results[i+1] = exp_val1;
    exp_results[i+2] = exp_val2;
    exp_results[i+3] = exp_val3;

    // Accumulate partial sums using separate accumulators.
    sum_acc0 += exp_val0;
    sum_acc1 += exp_val1;
    sum_acc2 += exp_val2;
    sum_acc3 += exp_val3;
  }

  // Combine the partial sums from the multiple accumulators.
  sum_total_0 = sum_acc0 + sum_acc1 + sum_acc2 + sum_acc3;

  // Handle remaining elements if 'size' is not a multiple of UNROLL_FACTOR.
  for (; i < size; ++i) {
    exp_results[i] = exp(softmax_input[i]);
    sum_total_0 += exp_results[i];
  }

  // Strength Reduction: Replace division inside the loop with multiplication.
  // Calculate the inverse of sum_total_0 once outside the loop.
  // For softmax, exp(x) is always positive, so sum_total_0 will be positive for size > 0.
  double inv_sum_total_0 = 1.0 / sum_total_0;

  // Reset loop counter for the second loop.
  i = 0;

  // Second loop: Compute the final softmax output.
  // Loop unrolling is applied again, and the division is replaced by multiplication.
  for (; i + UNROLL_FACTOR <= size; i += UNROLL_FACTOR) {
    // Load pre-computed exponential results.
    double exp_res0 = exp_results[i];
    double exp_res1 = exp_results[i+1];
    double exp_res2 = exp_results[i+2];
    double exp_res3 = exp_results[i+3];

    // Compute the final output using multiplication, which is generally faster than division.
    softmax_output[i] = exp_res0 * inv_sum_total_0;
    softmax_output[i+1] = exp_res1 * inv_sum_total_0;
    softmax_output[i+2] = exp_res2 * inv_sum_total_0;
    softmax_output[i+3] = exp_res3 * inv_sum_total_0;
  }

  // Handle remaining elements for the second loop.
  for (; i < size; ++i) {
    softmax_output[i] = exp_results[i] * inv_sum_total_0;
  }
}
```