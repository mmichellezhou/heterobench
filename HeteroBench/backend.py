from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple
import os

class Backend(ABC):
    """Abstract base class for different hardware backends."""
    
    def __init__(self, name: str):
        """
        Initialize the backend.
        
        Args:
            name: Name of the backend (e.g., "cpu", "npu")
        """
        self.name = name
    
    @abstractmethod
    def get_available_kernels(self) -> Dict[str, str]:
        """
        Get the available kernels for this backend.
        
        Returns:
            Dictionary mapping kernel names to file paths
        """
        pass
    
    @abstractmethod
    def create_prompt(self, complete_code: str, function_name: str) -> str:
        """
        Create a backend-specific prompt for the LLM.
        
        Args:
            complete_code: The original complete code
            function_name: Name of the function to optimize
            
        Returns:
            Formatted prompt string for the LLM
        """
        pass
    
    @abstractmethod
    def create_output(self, complete_code: str, optimized_code_generated: str, function_name: str) -> str:
        """
        Create the final optimized complete code by integrating the LLM-generated optimized code.
        
        Args:
            complete_code: The original complete code
            optimized_code_generated: The optimized code generated by the LLM
            function_name: Name of the function to optimize
            
        Returns:
            The complete optimized code ready for compilation/execution
        """
        pass
    
    @abstractmethod
    def get_output_code_name(self, function_name: str) -> str:
        """Get the output code name."""
        pass
    
    @abstractmethod
    def compile_and_run(self, benchmark_name: str, benchmark_path: str, output_dir: str) -> Dict:
        """
        Compile and run the optimized code.
        
        Args:
            benchmark_name: Name of the benchmark
            benchmark_path: Path to the benchmark directory
            output_dir: Directory for outputs
            
        Returns:
            Dictionary with compilation and execution results
        """
        pass
    
    @abstractmethod
    def analyze_run_output(self, run_output: str, benchmark_name: str) -> Dict:
        """
        Analyze the run output to extract performance metrics.
        
        Args:
            run_output: The stdout from running the program
            benchmark_name: Name of the benchmark
            
        Returns:
            Dictionary containing analysis results
        """
        pass
    
    def get_system_info(self) -> str:
        """
        Get hardware-specific system information for prompts.
        
        Returns:
            String describing the target hardware
        """
        return f"Target backend: {self.name}"

    @property
    def show_speedup_in_feedback(self):
        return True 